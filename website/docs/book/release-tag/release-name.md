---
id: release-name
title: Имя релизного тега
---

Помните ту картинку из первой главы с командой pvm update ?

import PvmInANutshell from '../_assets/pvm-in-a-nutshell.svg'

<PvmInANutshell />

В ней фигурируют зеленые кружочки с надписями `release-v1` и `release-v2`, это схематично изображены релизные теги,
которые фиксируют поднятие версий пакетов и факт релиза.

## Виды релизных тегов

По факту, в зависимости от выбранных настроек pvm будет по разному именовать релизный тег:

| Настройки | Вид тегов или тега |
| -- | -- |
| Простой репозиторий с одним пакетом | vX.Y.Z |
| Задана настройка `tagging.release_tag_package` и/или `versioning.unified` | vX.Y.Z |
| В остальных случаях | release-YYYY.MM.DD-{suffix} |

### Тег вида vX.Y.Z

Такой тег естественным образом получается если у нас простой репозиторий с одним пакетом.
В случае монорепозитория добиться такого тега можно двумя путями:

1. Через явное указание у какого пакета брать версию для релизного тега с семантичной версией:

```toml
[tagging]
release_tag_package = 'package-name'
```

Такой пакет обязан существовать.

2. Либо можно объеденить часть или все пакеты одной версией, которая и будет использоваться для формирования имени релизного тега:

```toml
[versioning]
unified = true # все пакеты имеют одну версию
# unified = ['/core/*'] # данная часть пакетов имеют одну версию, которая будет в имени релизных тегов
```

### Настройка сводного релизного тега

Кейс с тегом `release-YYYY.MM.DD-{suffix}` при этом можно настраивать через конфиг pvm:

```toml
[tagging.generic_tag]
prefix = 'release'
# date follows after prefix, delimited by '-' symbol
date_format = 'yyyy.MM.dd'
# suffix after date, could be name of package which exports list of strings
# or it could be explicit list of strings
suffixes = '@pvm/suffixes'
```

Опция `tagging.generic_tag.suffixes` отвечает за выбор суффиксов релизов, т.к. их может быть несколько за день, почему нет.
При этом можно задавать свой список строк:

```toml
[tagging.generic_tag]
suffixes = [
  'Metis',
  'Adrastea',
  'Amalthea',
  'Thebe',
  'Io',
  'Europa',
  'Ganymede',
  'Callisto',
  'Themisto',
  'Leda',
  'Himalia',
  'Ersa',
  'Pandia',
  'Elara',
  'Lysithea',
  'Dia',
  'Carpo',
  'Valetudo',
]
```

Или пакет, который экспортит такой список:

```toml
[tagging.generic_tag]
suffixes = '@pvm/suffixes'
```

import RingListSvg from '../_assets/ring-list.svg'
import RingListRotatedSvg from '../_assets/ring-list-rotated.svg'

Порядок выбора суффикса при этом такой:

1. Сначала переданный список слов трансформируется чтобы быть совместимым с [ограничениями](https://git-scm.com/docs/git-check-ref-format) которые есть в именовании тегов,
   например проблемы и всякие спецсимволы заменяются дефисом, некоторые комбинации символов вообще полностью вырезаются из строки. Также удаляются все дубликаты.
2. Затем выполняется фиксированный shuffle списка, т.е. сортировка не случайная, а задается через seed, seed берется из имени рутового пакета.
3. Теперь представим что получившийся список не имеет конца, и закольцован. Но при этом у нас есть индексы от 0 до последнего елемента в кольце.
   <br/><RingListSvg />
4. Затем берем суффикс из последнего релиза, если таковый был, и вращаем индексы так, чтобы следующий за найденным суффикс стал самым первым. 
   Допустим мы нашли что предыдущий суффикс был, условно, `d`. Значит теперь начало кольца переедет к следующему слову `e`.<br/>
   <RingListRotatedSvg />
5. Затем просто берем слово из этого списка начиная с самого первого. Если по каким-то причинам выбранное слово все же [не подходит](https://git-scm.com/docs/git-check-ref-format)
   значит берем следующее из списка. 
6. Если список был выбран полностью, тогда генерируется слово случайным образом из 7 букв.

## Теги для пакетов

Если опция `versioning.source` равна `tag` и пакеты имеют независимые версии, то также будет создаваться пачка тегов вида `pkg-name-vX.Y.Z`.
Однако такой подход не рекомендуется, в виду излишнего замусоривания тегами репозитория.

К релизному тегу, при его создании через [platform](../glossary.md#platform) API, также записываются release notes, о которых мы поговорим в следующей части главы.